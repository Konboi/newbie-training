
コンピューター基礎
====================

* 2013/4/9 10:30-12:30(くらい)

----------

アジェンダ
============

* 文字コードの話
  * オレは文字コードが嫌いだ
  * BOMって知ってる?
  * JIS系コード
  * CP932とは…
  * 改行コードの話
  * 実習


アジェンダ
==========

* スピードとレイテンシの話
  * スピードのオーダー
  * 西濃運輸は神

アジェンダ
===============

* 計算量の話
  * 計算量のオーダー
  * O(1)
  * O(logN)
  * O(N)
  * O(NlogN)
  * O(N)



----

オレは文字コードが嫌い
=======================

* 文字コードとは?
  * UTF-8
  * Shift_JIS
  * JIS X 0208
  * JISコード
  * Unicode
  * UTF-16
  * EUC-JP
  * JIS X 0202
  * ISO-2022-JP
  * JIS X 0213


整理しましょう
=======================

* 文字コードっていうのは非常に曖昧な言葉
* 情弱が文字コードの話をすると以下の2つが混ざっている
  * 文字の集合(coded character set)
  * 文字の符号化方式(character encoding schema)

分割するとこんなかんじ

文字集合(文字コードセット) | 符号化方法(文字エンコーディング)
---------------------------|----------------------------------
Unicode                    | UTF-8
                           | UTF-16 (BE/LE)
                           | UTF-7
JIS X 0208                 | Shift_JIS / CP932
                           | EUC-JP
                           | ISO-2022-JP

----

エンディアンの話
=====================

* 16bit/32bitのデータの格納方法はどうする?
* たとえば 0xABCD をファイルに保存したらどうなるか?
* 0xAB 0xCDと保存するか、0xCD 0xABと保存するかはCPU次第
* これをエンディアンという
  * 0xAB 0xCD と保存する → ビッグエンディアン
  * 0xCD 0xAB と保存する → リトルエンディアン
* Intel x86 CPUはリトルエンディアン
* ARM CPUはビッグエンディアン
  * バイエンディアンだがネイティブはビッグエンディアン
* Javaはビッグエンディアン(ネットワークバイトオーダーに一致させている)


エンディアンの話
==================

* エンディアン問題が出やすい場所
  * 他のマシンにファイルを持っていったとき
  * ネットワークでバイナリを送信したとき
* OSIはビッグエンディアンでネットワークにバイナリを流そうと言っている
  * 「ネットワークバイトオーダー」というのはビッグエンディアンのこと
  * C APIに htons, htonl というのがありよしなにビッグエンディアンにする

* odコマンドで確認できるよ!
 * od -t x (xIで4バイト、xSで2バイト、xCで1バイト)

----

日本語文字コードセット
==========================

* JIS X 0208のこと
  * ちょいちょい拡張されてJIS X 0212とかJIS X 0213がでてる
* 日本のJIS規格で決まってる
* 符号化方式は附属書に載ってるけど実用化されてるのはShift_JISくらい


具体的なコード例
=================

* あ : 2422
* じゃあバイナリエディタで0x24 0x22と書き込んだファイルを作ろう!
  * ポチっとな…
* あれぇ…

JISの符号化方式
=================

* Shift_JIS
  * ASCIIで使ってる領域を1バイト目に出さないようにする方式
* EUC-JP
  * JIS X 0208のコードに0x8080加算した値を保存する方式
* ISO-2022-JP
  * 制御文字を使ってASCIIとJISの切れ目を明示する
  * 7bitで転送できる(ので、メールなどで使われた)

----

Unicodeの話
================

* いまバージョン6.0 か 6.1くらいだったはず
* JIS X 02xx系使っていいのは小学生までだよねー
* U+XXXXXX という書き方でUnicode文字集合の1つの文字を特定する(XXXは16進数)
  * あ: は U+3042

----

UTF-8
=============

可変長の符号化方式
-------

* 簡単に言うと
  * Unicodeの最初のほうは1バイト
  * わりと前のほうは2バイト
  * 真ん中らへんは3バイト
  * 結構うしろのほうは4バイト
  * いま割りあたってないところは5バイトとか6バイト使う

* 身近なところでいうと?
  * ASCIIコードは1バイト
  * 日本語は3バイト


じゃあJIS系とどっちがサイズで有利なの?
----------------------------------------

* 基本的にはUTF-8のほうがサイズがでかくなるね


UTF-16
=========

固定長の符号化方式
--------------------

* 作った当時は16bitで収まりそうだったから16bit固定で保存するようにした。
* しかし中国4000年の歴史で大量の漢字が存在するため16bit(約65000文字)では足りないことが判明
  * 実際、TRON系の超漢字では18万文字の文字をサポートしている
* そこでサロゲートペアを導入
  * 上位サロゲート1024文字x下位1024文字の組み合わせを使い、4バイトで100万文字を表現できる使用を追加した


--------

BOMとは
========

* U+FEFF というコードのことをByte Order Markとよぶ
 * ただし、これは俗名である
* U+FEFFの正式な名前は ZERO WIDTH NO-BREAK SPACE
  * 幅ゼロで改行禁止のスペース
  * なんじゃそれ
* 表示に1ピクセルも影響を与えないスペースという定義の文字

つまり?
--------

* これを埋めておいても表示上の影響はない
* これを読み込んでエンディアン判別に使おう!
  * 間違ったエンディアンで読み込むと 0xFFFEになる
  * じゃあU+FFFEは予約文字ということにして使用しないようにしよう
* ファイルの最初にU+FEFFを埋め込んでUTF-16 BE/LEの判別に使おう!

これにより!
-------

* Byte Order Markと呼ばれるようになった




----


TCP 3Wayハンドシェイク
======================

* 西濃運輸は神 のコピペで考えるとわかりやすい

````
ﾌﾟﾙﾙ…ﾌﾟﾙﾙﾙ
俺「はい、もしもし」
西濃「おるかーー？」
俺「え…？ど、どちらさまでしょうか…？」
西濃「よーし、おるな！いくわ！」
俺「え、え！？」

ﾋﾟﾝﾎﾟｰﾝ、ｶﾞﾁｬ

西濃「ここやで、ﾄﾝﾄﾝ（はんこ押すとこを指で叩きながら）」


　　　西　濃　は　神


````





